"""
    Python with RabbitMQâ€”simplified so you won't have to.

    :copyright: 2020-Present by Alexandre Gerona.
    :license: MIT, see LICENSE for more details.

    Full documentation is available at https://pyrmq.readthedocs.io
"""

from contextlib import suppress

import pytest

from pyrmq import Publisher

TEST_EXCHANGE_NAME = "sample_exchange"
TEST_QUEUE_NAME = "test_queue_name"
TEST_ROUTING_KEY = "test_routing_key"

TEST_PRIORITY_EXCHANGE_NAME = "sample_priority_exchange"
TEST_PRIORITY_QUEUE_NAME = "sample_priority_queue_name"
TEST_PRIORITY_ROUTING_KEY = "sample_priority_routing_key"
TEST_PRIORITY_ARGUMENTS = {"x-max-priority": 5, "x-queue-type": "classic"}


@pytest.fixture(scope="function")
def publisher():
    publisher = Publisher(
        exchange_name=TEST_EXCHANGE_NAME,
        queue_name=TEST_QUEUE_NAME,
        routing_key=TEST_ROUTING_KEY,
    )
    return publisher


@pytest.fixture(scope="function")
def priority_publisher():
    publisher = Publisher(
        exchange_name=TEST_PRIORITY_EXCHANGE_NAME,
        queue_name=TEST_PRIORITY_QUEUE_NAME,
        routing_key=TEST_PRIORITY_ROUTING_KEY,
        queue_args=TEST_PRIORITY_ARGUMENTS,
    )
    return publisher


@pytest.fixture(scope="function")
def publisher_session(publisher):
    from pyrmq import Consumer

    # Create a dummy consumer to declare the queue
    dummy_consumer = Consumer(
        exchange_name=TEST_EXCHANGE_NAME,
        queue_name=TEST_QUEUE_NAME,
        routing_key=TEST_ROUTING_KEY,
        callback=lambda x: x,
    )

    # Connect and declare the queue
    dummy_consumer.connect()
    dummy_consumer.declare_queue()

    # Delete queue generated by Publisher on test setup
    channel = publisher.connect()
    channel.queue_purge(TEST_QUEUE_NAME)
    with suppress(Exception):
        channel.queue_purge(f"{TEST_QUEUE_NAME}.retry")
    yield publisher
    # Delete queue generated by Publisher on test teardown
    channel = publisher.connect()
    channel.queue_purge(TEST_QUEUE_NAME)
    channel.queue_delete(TEST_QUEUE_NAME)


@pytest.fixture(scope="function")
def priority_session(priority_publisher: Publisher):
    from pyrmq import Consumer

    # Create a dummy consumer to declare the queue with priority
    dummy_consumer = Consumer(
        exchange_name=TEST_PRIORITY_EXCHANGE_NAME,
        queue_name=TEST_PRIORITY_QUEUE_NAME,
        routing_key=TEST_PRIORITY_ROUTING_KEY,
        callback=lambda x: x,
        queue_args=TEST_PRIORITY_ARGUMENTS,
    )

    # Connect and declare the queue
    dummy_consumer.connect()
    dummy_consumer.declare_queue()

    # Delete queue generated by Publisher on test setup
    channel = priority_publisher.connect()
    channel.queue_purge(TEST_PRIORITY_QUEUE_NAME)
    yield priority_publisher
    # Delete queue generated by Publisher on test teardown
    channel = priority_publisher.connect()
    channel.queue_purge(TEST_PRIORITY_QUEUE_NAME)
    channel.queue_delete(TEST_PRIORITY_QUEUE_NAME)


@pytest.fixture(scope="function", autouse=True)
def clean_specific_queues():
    """Clean up specific resources before each test to ensure isolation."""
    from pyrmq import Consumer

    # Create a consumer for cleanup only
    consumer = Consumer(
        exchange_name="cleanup_exchange",
        queue_name="cleanup_queue",
        routing_key="cleanup_key",
        callback=lambda x: x,
    )

    # Connect to get a channel
    channel = consumer.connect()

    # Clean up exchanges and queues - only delete, don't create
    with suppress(Exception):
        # Delete test queues
        for queue in [
            "first_queue",
            "second_queue",
            "publisher_first_queue",
            "publisher_second_queue",
            "test_queue_name",
            TEST_QUEUE_NAME,
            TEST_PRIORITY_QUEUE_NAME,
            TEST_QUEUE_NAME + ".retry",
            "classic_publisher_test_queue",
            "classic_consumer_test_queue",
            "nack_queue_name",
            "quorum_priority_test_queue",
            "temp_queue",
        ]:
            try:
                channel.queue_delete(queue)
            except Exception:
                pass

        # Delete test exchanges
        for exchange in [
            "first_exchange",
            "second_exchange",
            "headers_exchange_name",
            "test_headers_exchange",
            TEST_EXCHANGE_NAME,
            TEST_PRIORITY_EXCHANGE_NAME,
            TEST_QUEUE_NAME + ".retry",
            "nack_exchange_name",
            "isolated_exchange",
            "quorum_priority_exchange",
        ]:
            try:
                # Skip deleting default exchanges
                if exchange not in [
                    "",
                    "amq.direct",
                    "amq.fanout",
                    "amq.topic",
                    "amq.headers",
                ]:
                    channel.exchange_delete(exchange)
            except Exception:
                pass
